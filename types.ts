









export interface RawNode {
  id: number;
  name: string;
  children: RawNode[];
  depth: number;
  parent: RawNode | null;
}

// D3Node combines our RawNode with d3's simulation properties
export interface D3Node extends RawNode {
  // These properties are added by the d3 force simulation
  index?: number;
  x?: number;
  y?: number;
  vx?: number;
  vy?: number;
  fx?: number | null;
  fy?: number | null;
}

export interface D3Link {
  source: D3Node | string | number;
  target: D3Node | string | number;
  index?: number;
}

// ---- New types for Citations ----

export interface SourceArticle {
  id: string;
  source: 'SEP' | 'IEP';
  title: string;
  url: string;
}

export interface Citation {
  sourceId: string;
  sourceTitle: string;
  source: 'SEP' | 'IEP';
  url: string;
  citedText: string;
}

// ---- New types for Map Builder ----

export type RelationshipType = string;

export interface KindleNote {
  id: string;
  heading: string;
  text: string;
  page: number | null;
  type: 'highlight' | 'note';
  sourceId: string;
  section?: string;
}

export interface UserNote {
  id: string;
  title: string;
  content: string; // HTML content from the rich-text editor
  createdAt: number;
  updatedAt: number;
  tagIds?: string[];
}

export interface MapNode {
  id: number | string; // Use the original node ID or a generated string for AI/user nodes
  name:string;
  x: number;
  y: number;
  shape: 'rect' | 'circle';
  width: number;
  height: number;
  isAiGenerated?: boolean;
  synthesisInfo?: {
    synthesis: string;
    reasoning: string;
  };
  isHistorical?: boolean;
  isDialectic?: boolean; // For counter-arguments or figures generated by the Dialectic Engine
  isCounterExample?: boolean; // For counter-examples from definition analysis
  isUserDefined?: boolean; // For nodes created directly by the user
  textColor?: string;
  isCitation?: boolean;
  citationData?: Citation;
  userNotes?: UserNote[];
}

export interface MapLink {
  source: number | string; // ID of source MapNode
  target: number | string; // ID of target MapNode
  pathStyle: 'straight' | 'curved';
  curveDirection?: number; // 1 for right, -1 for left
  relationshipTypes: RelationshipType[];
  relationshipType?: RelationshipType; // For migration from old format
  justification?: string | { text: string; citations: Citation[] }; // Updated to support structured justifications
  justificationState?: 'idle' | 'loading' | 'success' | 'error';
  implications?: string[];
  implicationsState?: 'idle' | 'loading' | 'success' | 'error';
  isHistorical?: boolean;
  isCounterExampleLink?: boolean;
  formalizationState?: 'idle' | 'loading' | 'success' | 'error';
  formalRepresentation?: string;
}

export interface FormalizationChoice {
    formalRepresentation: string;
    suggestedSystem: string;
    rationale: string;
}

export interface FormalizationResult {
    choices: FormalizationChoice[];
    critique: string;
    propositions: { variable: string; meaning: string }[];
}

export interface LogicalConstruct {
    id: string;
    premiseNodeIds: (string | number)[];
    conclusionNodeId: string | number;
    operator: 'AND'; // Can be extended to 'OR', etc. in the future
    formalRepresentation: string;
    critique: string;
    propositions: { variable: string; meaning:string }[];
    suggestedSystem: string;
    rationale: string;
}

// --- Types for Feed Page ---
export interface TrackedFeed {
    id: string; // url can be the id
    url: string;
    nodeId: number;
    nodeName: string;
    error?: string | null;
    isLoading?: boolean;
}

export interface Publication {
    title: string;
    author: string | null;
    publicationInfo: string | null;
    link: string;
    sourceNodeName: string; // The name of the category/node this feed belongs to
    sourceUrl: string; // To identify which feed it belongs to
    isNew?: boolean;
}

// --- Types for Research Analysis ---
export interface KeyTheme {
    theme: string;
    description: string;
    representativeTitles: string[];
}
  
export interface ResearchAnalysisData {
    generalSummary: string;
    keyThemes: KeyTheme[];
    potentialDebates: string;
    notableAuthors: string[];
    futureQuestions: string[];
}

// --- Types for Project Diary ---
export type ProjectActivityType =
  | 'EXPLORE_CONCEPT'
  | 'FIND_RELATED'
  | 'ADD_TO_TRAY'
  | 'CREATE_MAP_LINK'
  | 'ADD_FEED'
  | 'VIEW_PUBLICATION'
  | 'ANALYZE_GENEALOGY'
  | 'EXPLORE_IMPLICATIONS'
  | 'CHANGE_CONCEPT'
  | 'SYNTHESIZE_REGION'
  | 'ANALYZE_ARGUMENT'
  | 'FORMALIZE_ARGUMENT'
  | 'CREATE_USER_NODE'
  | 'CREATE_LOGICAL_CONSTRUCT'
  | 'GENERATE_JUSTIFICATION'
  | 'ANALYZE_DEFINITION'
  | 'EDIT_NOTE'
  | 'ASK_AI_ASSISTANT'
  | 'START_BELIEF_CHALLENGE'
  | 'BUILD_BELIEF_CHALLENGE_PATH'
  | 'COMPLETE_BELIEF_CHALLENGE'
  | 'INITIATE_BELIEF_CHALLENGE_FROM_MAP'
  | 'IMPORT_NOTES'
  | 'ADD_NOTE_TO_MAP'
  | 'APPEND_NOTE_TO_NODE'
  | 'SOCRATIC_ACTION_TAKEN'
  | 'SOCRATIC_SUGGESTION_TRIGGERED'
  | 'ANALYZE_RESEARCH_TRENDS'
  | 'VOICE_NOTE'
  | 'CREATE_NOTE'
  | 'DELETE_NOTE'
  | 'CONCEPTUAL_BRIDGE_IMAGE_PARSE'
  | 'CONCEPTUAL_BRIDGE_ANALYSIS';

export interface ProjectActivity {
  id: string;
  timestamp: number;
  type: ProjectActivityType;
  payload: {
    provenance?: {
        prompt: string;
        systemInstruction?: string;
        rawResponse: string;
        model: string;
        inputTokens?: number;
        outputTokens?: number;
        totalTokens?: number;
    };
    [key: string]: any;
  };
}

// --- Type for Relationship Types ---
export interface CustomRelationshipType {
    name: string;
    description: string;
    color: string;
}

// --- Types for Belief Flip Challenge ---
export interface BeliefStatement {
  belief: string;
  initialConfidence: number;
}

export interface SuggestedConcept {
    nodeId: number;
    topicName: string;
    rationale: string;
}

export interface ChallengeStep {
  nodeId: number;
  topicName: string;
  summary: string;
  provocativeQuestion: string;
  rationale: string; // The rationale for why it was included in the path, from the build step
  userConfidence?: number;
  status: 'pending' | 'completed';
}

export interface ChallengeSession {
  id: string;
  startTime: number;
  endTime?: number;
  beliefStatement: BeliefStatement;
  challengePath: ChallengeStep[];
  suggestedConcepts: SuggestedConcept[];
  finalSynthesis?: string;
  status: 'generating_suggestions' | 'topic_selection' | 'active' | 'completed' | 'discarded';
}

export type PublicationType = 'book' | 'article' | 'chapter' | 'thesis';

export interface ImportedNoteSource {
    id: string;
    publicationType: PublicationType;
    title: string;
    author: string;
    notes: KindleNote[];
    
    // Book-specific
    coverImageUrl?: string;
    description?: string; // For books: synopsis; for articles: abstract
    
    // Academic metadata
    doi?: string;
    journalTitle?: string;
    bookTitle?: string; // For book chapters
    publicationDate?: string;
    publisher?: string;
    volume?: string;
    issue?: string;
    pages?: string;
    keywords?: string[];
}

// --- Type for Data Portability ---

export interface ConceptualMap {
  id: string;
  name: string;
  layout: { 
    nodes: MapNode[], 
    links: MapLink[],
    logicalConstructs: LogicalConstruct[],
  };
}

export interface AppTag {
  id: string;
  name: string;
  color: string;
}

export interface AppSessionData {
    maps: ConceptualMap[];
    activeMapId: string | null;
    mapTrayConceptIds: number[];
    trackedFeeds: TrackedFeed[];
    seenPublicationIds: string[];
    projectDiary: ProjectActivity[];
    beliefFlipChallenges: ChallengeSession[];
    importedNoteSources?: ImportedNoteSource[];
    processedNoteIds?: string[];
    tags?: AppTag[];
    nexusLayout?: {
        notePositions: { userNoteId: string; x: number; y: number; width: number; height: number; }[];
        links: { sourceNoteId: string; targetNoteId: string; }[];
    };
    // DEPRECATED, will be migrated
    mapLayout?: { 
        nodes: MapNode[], 
        links: MapLink[],
        logicalConstructs: LogicalConstruct[],
    };
    // Deprecated, use importedNoteSources instead
    importedNotes?: {
        title: string; // formerly bookTitle
        author: string;
        notes: KindleNote[];
    } | null;
}

export interface Project {
  id: string;
  name: string;
  data: AppSessionData;
}

export interface MultiProjectSession {
  version: number;
  activeProjectId: string | null;
  projects: Project[];
  customRelationshipTypes: CustomRelationshipType[];
  disabledDefaultTypes: string[];
  disabledCustomTypes: string[];
  aiAssistanceLevel?: 'off' | 'moderate' | 'rigorous';
}

// --- Type for Confirmation Dialog ---
export type ConfirmationRequestHandler = (options: {
  message: string;
  onConfirm: () => void;
  title?: string;
  confirmText?: string;
}) => void;

// --- Types for Definition Analysis ---
export interface DefinitionResult {
    source: string;
    summary: string;
}

export interface CounterExampleResult {
    counterExample: string;
    justification: string;
}

export interface DefinitionAnalysisState {
    x: number;
    y: number;
    link: MapLink;
    sourceNodeName: string;
    targetNodeName: string;
    loadingState: 'idle' | 'loadingDefinitions' | 'loadingCounterExamples';
    definitions: DefinitionResult[];
    counterExamples: Map<DefinitionResult, CounterExampleResult[]>;
    error: string | null;
}

// --- Types for Conceptual Bridge ---
export interface ParsedMindMapNode {
  name: string;
  children: ParsedMindMapNode[];
}

export interface MappingSuggestion {
  philPapersNodeId: number;
  philPapersNodeName: string;
  rationale: string;
}

export interface BridgeAnalysis {
  nonEquivalentNodes: { name: string; reason: string }[];
  uncoveredCategories: { name: string; reason: string }[];
  restructuringAdvice: string[];
}

// --- START OF MAP BUILDER TYPES ---

export interface RelationshipTypeInfo {
    type: RelationshipType;
    color: string;
    description: string;
}

export interface MapBuilderProps {
    layout: { nodes: MapNode[], links: MapLink[], logicalConstructs: LogicalConstruct[] };
    setLayout: (updater: React.SetStateAction<{ nodes: MapNode[], links: MapLink[], logicalConstructs: LogicalConstruct[] }> | ((current: { nodes: MapNode[]; links: MapLink[]; logicalConstructs: LogicalConstruct[]; }) => { nodes: MapNode[]; links: MapLink[]; logicalConstructs: LogicalConstruct[]; })) => void;
    logActivity: (type: ProjectActivityType, payload: { [key: string]: any }) => void;
    relationshipTypes: RelationshipTypeInfo[];
    onExportMapData: () => Promise<{ success: boolean; message: string }>;
    allNodes: D3Node[];
    initialWorkbenchData?: any;
    onClearInitialWorkbenchData?: () => void;
    beliefChallenge: ReturnType<typeof import('../hooks/useBeliefFlipChallenge').useBeliefFlipChallenge>;
    setIsChallengeOpen: (isOpen: boolean) => void;
    aiAssistanceLevel: 'off' | 'moderate' | 'rigorous';
    onAddNoteToMap: (note: KindleNote, position: { x: number, y: number }) => void;
    onAddMultipleNotesToMap: (notes: KindleNote[], position: { x: number, y: number }) => void;
    onAppendToNodeNotes: (nodeId: string | number, notes: KindleNote[]) => void;
    onRequestConfirmation: ConfirmationRequestHandler;
    notesToPlace: KindleNote[] | null;
    onClearNotesToPlace: () => void;
    onOpenStudio: (nodeId: string | number, x: number, y: number) => void;
    focusNodeId?: (string | number) | null;
    onFocusComplete?: () => void;
}

export interface NodeContextMenuState {
    x: number;
    y: number;
    nodeId: number | string;
}

export interface DropOnNodeMenuState {
    x: number;
    y: number;
    targetNodeId: string | number;
    droppedNotes: KindleNote[];
}

export interface LinkContextMenuState {
    x: number;
    y: number;
    link: MapLink;
}

export interface EditLinkTypesMenuState {
    anchorEl: HTMLElement;
    link: MapLink;
}

export interface FloatingTooltipState {
    x: number;
    y: number;
    title?: string;
    text: string | string[] | RelationshipTypeInfo[] | { name: string, summary: string }[] | LogicalConstruct | Citation[] | KindleNote[];
    type?: RelationshipType | 'justification' | 'synthesis' | 'genealogy' | 'formalism' | 'logical_construct' | 'citation' | 'implications' | 'source_note';
    color?: string;
    linkForCitation?: MapLink;
}

export interface ChangeNodeState {
    x: number;
    y: number;
    nodeId: number | string;
}

export interface SelectionBox {
    startX: number;
    startY: number;
    endX: number;
    endY: number;
}

export interface DialecticAnalysisState {
    x: number;
    y: number;
    link: MapLink;
}

export interface KeyVoice {
    name: string;
    relevance: string;
}

export interface Counterargument {
    title: string;
    description: string;
}

export interface AnalysisResult {
    counterarguments: Counterargument[];
    keyVoices: {
        proponents: KeyVoice[];
        opponents: KeyVoice[];
    };
}

export type LogicalWorkbenchState = {
    x: number;
    y: number;
    mode?: 'link' | 'combined' | 'text-to-map';
} & (
    { link: MapLink; combinedArgument?: never; deconstructed?: never } |
    { link?: never; combinedArgument: { premises: MapNode[], conclusion: MapNode }; deconstructed?: never } |
    { link?: never; combinedArgument?: never; deconstructed: { premises: string[], conclusion: string } }
);

export interface ColorPickerState {
    x: number;
    y: number;
    nodeId: number | string;
}

export interface BeliefConfirmationState {
    link: MapLink;
    x: number;
    y: number;
}

// --- Types for Socratic Assistant ---
export type SocraticActionKey = 'add_counterexample' | 'add_alternative_hypothesis' | 'refine_link' | 'remove_link';

export type SocraticMovementKey = 'counterexample' | 'alternative_hypothesis';

export interface SocraticSuggestion {
    id: string;
    movementKey: SocraticMovementKey;
    triggerType: 'link';
    triggerId: string; // e.g., `${sourceId}-${targetId}`
    sourceName: string;
    targetName: string;
    position: { x: number; y: number };
    availableActions: SocraticActionKey[];
    description: string;
}

export interface PhilosophicalMove {
    key: SocraticMovementKey;
    name: string;
    description: string;
    condition: (link: MapLink) => boolean;
    getSuggestion: (link: MapLink, sourceNode: MapNode, targetNode: MapNode, position: {x: number, y: number}) => SocraticSuggestion;
}

// --- END OF MAP BUILDER TYPES ---
